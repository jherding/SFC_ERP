% Implementation of cluster-based permutation test of contrast images vs. 
% a zero-valued matrix (null-hypothesis), i.e. comparing the observed effect vs. sign-flipping distribution of the effect
% It can be used as a substitute for the second-level one-sample t-test of
% time-frequency EEG data from SPM. The advantage of this permutation test
% is that it does a family-wise-error correction over all necessary
% dimensions (space, time, frequency).

% pool over all studies that showed the ERP effect
%% parameter settings
clear all;
addpath(genpath('/home/jan/spm12'))

project_dir = {'/path/to/your/data1', '/path/to/your/data1', '/path/to/your/data1', '/path/to/your/data1', '/path/to/your/data1', '/path/to/your/data1'};
modelID     = 'ERP_GLM_ortho_shifted_distance_model_coh_preproc_dev'; %'ERP_GLM_sign_abs_diff_model_coh_preproc_dev'; %'ERP_GLM_subj_abs_diff_coh_preproc_ORTHO'; %'ERP_GLM_with_sacc_artefacts_pos_diffs'; %'ERP_GLM_TOE_subj_diff_f2_fullset';

% load a reference file to get all the stuff like time and electrode labels
ref_file = fullfile(project_dir{1}, 'subject02', 'mbfraeSFC_ERP_f2_locked02');
D = spm_eeg_load(ref_file);

% set default eeg locations .. just to be on the save side
S = [];
S.D = D;
S.task = 'defaulteegsens';
S.save = 0;
D = spm_eeg_prep(S);

dat        = D.fttimelock();      % transform SPM data set into fieldtrip data set
dat.label  = dat.label(1:64);     % remove external electrodes from labels
dat.dimord = 'rpt_chan_time';     % set appropriate labels for the dimensions of data

% get two copies for both regressors/effects
content_dat    = dat;
difficulty_dat = dat;

pooled_content_dat = [];
pooled_difficulty_dat = [];
N = 0;

for i=1:length(project_dir)
    % load betas of ERP GLM data
    load(fullfile(project_dir{i}, modelID));

    N        = N + size(betas,4);
    nsamples = size(betas,3);
    nbetas   = size(betas,2);
    nelecs   = size(betas,1);

    % assign data
    pooled_content_dat    = [pooled_content_dat; permute(squeeze(betas(:,1,:,:)), [3 1 2])];
    pooled_difficulty_dat = [pooled_difficulty_dat; permute(squeeze(betas(:,2,:,:)), [3 1 2])];

end

% assign data
content_dat.trial    = pooled_content_dat;
difficulty_dat.trial = pooled_difficulty_dat;

% create data set of same size as observed data with only zeros (null-hypothesis)
zero_dat       = dat;
zero_dat.trial = zeros(size(content_dat.trial));



% most important settings of permutation test. More parameters can be set
% further down
cluster_defining_threshold = 0.005;   % alpha-level that is used to define a cluster
min_neighbours             = 1;      % minimal amount of neighbouring channels that have to share an effect to consider 
                                     % the effect as a spatially coherent cluster
permutation_threshold      = 0.05;   % probability of random occurence of clusters in permutation sample 
                                     % that exhibit a larger effect than the observed data
num_permutation            = 500;    % number of random samples that should be generated by shuffling the data labels



%% set configuration for permutation test

% prepare neighbourhood structure of electrodes
cfg_neighbours.method = 'template';
cfg_neighbours.template = 'biosemi64_neighb.mat';
cfg_neighbours.feedback = 'yes';   % if 'yes' a plot will be shown of neighbour structure

cfg = [];
cfg.neighbours       = ft_prepare_neighbours(cfg_neighbours, dat);
cfg.channel          = 'all';
cfg.latency          = [0 2]; %'all';
cfg.method           = 'montecarlo';
% config for cfg.method - cluster-defining statisitics
cfg.statistic        = 'depsamplesT';
cfg.correctm         = 'cluster';
cfg.clusteralpha     = cluster_defining_threshold;        
cfg.clusterstatistic = 'maxsum'; %'maxsum', 'maxsize', 'wcm' (default = 'maxsum')
cfg.minnbchan        = min_neighbours;
% config for statistics of permutation test
cfg.computecritval   = 'no';
cfg.tail             = 0;
cfg.clustertail      = 0;
cfg.alpha            = permutation_threshold;   % FWE correction threshold 
cfg.numrandomization = num_permutation;

% create the right design: here, a comparison vs. a zero-data set (i.e. paired t-test with a null-condition)
design = zeros(2,2*N);
for i = 1:N
  design(1,i)   = i;
  design(1,N+i) = i;
end

design(2,1:N)        = 1;
design(2,N+1:2*N)    = 2;

cfg.design   = design;
cfg.uvar     = 1;                  % row number of design that contains the labels of the UOs (subjects or trials)
cfg.ivar     = 2;                  % row number of the design that contains the labels of the conditions that must be 
                                   % compared. The labels are the numbers 1 and 2.

content_stat    = ft_timelockstatistics(cfg, content_dat, zero_dat);
difficulty_stat = ft_timelockstatistics(cfg, difficulty_dat, zero_dat);

%% plot the results

try
    % get significant clusters for CONTENT encoding
    pos_cluster_pvals = [content_stat.posclusters(:).prob];
    pos_signif_clust = find(pos_cluster_pvals < content_stat.cfg.alpha);
    % make a boolean matrix of which (channel,time)-pairs are part of a significant cluster
    pos_content = ismember(content_stat.posclusterslabelmat, pos_signif_clust);
catch
    disp('no positive cluster')
    pos_content = zeros(size(content_stat.stat));
end

try
    % and now for the negative clusters...
    neg_cluster_pvals = [content_stat.negclusters(:).prob];
    neg_signif_clust = find(neg_cluster_pvals < content_stat.cfg.alpha);
    neg_content = ismember(content_stat.negclusterslabelmat, neg_signif_clust);
catch
    disp('no negative cluster')
    neg_content = zeros(size(content_stat.stat));
end

try
    % get significant clusters for DIFFICULTY encoding
    pos_cluster_pvals = [difficulty_stat.posclusters(:).prob];
    pos_signif_clust = find(pos_cluster_pvals < difficulty_stat.cfg.alpha);
    % make a boolean matrix of which (channel,time)-pairs are part of a significant cluster
    pos_diffi = ismember(difficulty_stat.posclusterslabelmat, pos_signif_clust);
catch
    disp('no positive cluster')
    pos_diffi = zeros(size(difficulty_stat.stat));
end

try
    % % and now for the negative clusters...
    neg_cluster_pvals = [difficulty_stat.negclusters(:).prob];
    neg_signif_clust = find(neg_cluster_pvals < difficulty_stat.cfg.alpha);
    neg_diffi = ismember(difficulty_stat.negclusterslabelmat, neg_signif_clust);
catch
    disp('no negative cluster')
    neg_diffi = zeros(size(difficulty_stat.stat));
end

cfg           = [];
cfg.parameter = 'stat';
cfg.layout    = 'biosemi64.lay';
cfg.colorbar  = 'no';
cfg.comment   = 'no';
cfg.zlim      = [-8 8];
cfg.marker = 'off';
cfg.highlight = 'on';
cfg.highlightmarkersize = 10;
cfg.highlightsymbol = '.';

step_size = 0.1;
start_point = 0.25;
num_plots = 11;
figure
for i=1:num_plots
    cfg.xlim      = [start_point+step_size*(i-1) start_point+step_size*i];
    
    [~, ind_start] = min(abs(content_stat.time - cfg.xlim(1)));
    [~, ind_end]   = min(abs(content_stat.time - cfg.xlim(2)));
    
    pos_content_int = any(pos_content(:, ind_start:ind_end), 2);
    neg_content_int = any(neg_content(:, ind_start:ind_end), 2);
   
    cfg.highlightchannel = find(pos_content_int | neg_content_int);
    
    % plot content effect
    axes('position', [((i-1)*0.08) 0.6 0.15 0.15], 'FontSize', 15)
    ft_topoplotER(cfg, content_stat);
    title(sprintf('%1.2f - %1.2f sec', cfg.xlim))
    
    pos_diffi_int = any(pos_diffi(:, ind_start:ind_end), 2);
    neg_diffi_int = any(neg_diffi(:, ind_start:ind_end), 2);
    cfg.highlightchannel = find(pos_diffi_int | neg_diffi_int);
    
    % plot difficulty effect
    axes('position', [((i-1)*0.08) 0.2 0.15 0.15], 'FontSize', 15)
    ft_topoplotER(cfg, difficulty_stat);
    title(sprintf('%1.2f - %1.2f sec', cfg.xlim))
    
end
pos = get(gca, 'position');
colorbar('FontSize', 15);
set(gca, 'position', pos)

axes('position', [0 0 1 1])
text(0.02, 0.58, 'neg diffs', 'FontSize', 20)
text(0.02, 0.18, 'pos diffs', 'FontSize', 20)
set(gca, 'Visible', 'off')

set(gcf, 'renderer', 'painters')
